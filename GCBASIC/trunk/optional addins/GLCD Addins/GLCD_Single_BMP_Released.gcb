'    Graphical BMP to GCB routines for the GCBASIC compiler
'    Copyright (C) 2014 Evan Venn

'    This library is free software; you can redistribute it and/or
'    modify it under the terms of the GNU Lesser General Public
'    License as published by the Free Software Foundation; either
'    version 2.1 of the License, or (at your option) any later version.

'    This library is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
'    Lesser General Public License for more details.

'    You should have received a copy of the GNU Lesser General Public
'    License along with this library; if not, write to the Free Software
'    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
'
'    Initial test release 14092014

'    You can choose two Pics... or change to your own chip.

#chip 16f877a, 20
'2024 bytes max in a table - why?

'  Setup GLCD
         #define GLCD_TYPE GLCD_TYPE_KS0108
         #define GLCD_WIDTH 128
         #define GLCD_HEIGHT 64
         ' #define GLCDFontWidth 6

         #define GLCD_CS1 PORTa.4'D12 to actually since CS1, CS2 can be reversed on some devices
         #define GLCD_CS2 PORTa.5

         #define GLCD_DB0 PORTD.0 'D0 to pin 7 on LCD
         #define GLCD_DB1 PORTD.1 'D1 to pin 8 on LCD
         #define GLCD_DB2 PORTD.2 'D2 to pin 9 on LCD
         #define GLCD_DB3 PORTD.3 'D3 to pin 10 on LCD
         #define GLCD_DB4 PORTD.4 'D4 to pin 11 on LCD
         #define GLCD_DB5 PORTD.5 'D5 to pin 12 on LCD
         #define GLCD_DB6 PORTD.6 'D6 to pin 13 on LCD
         #define GLCD_DB7 PORTD.7 'D7 to pin 14 on LCD


         #define GLCD_RS PORTa.0
         #define GLCD_Enable PORTA.1
         #define GLCD_RW PORTA.2
         #define GLCD_RESET PORTA.3



'#chip 16f1939, 32
'#config mclr_on, PLLEN_ON
'
'         #define GLCD_TYPE GLCD_TYPE_KS0108
'         #define GLCD_WIDTH 128
'         #define GLCD_HEIGHT 63
'         ' #define GLCDFontWidth 6
'
'         #define GLCD_CS1 PORTa.7'D12 to actually since CS1, CS2 can be reversed on some devices
'         #define GLCD_CS2 PORTa.6
'
'         #define GLCD_DB0 PORTD.0 'D0 to pin 7 on LCD
'         #define GLCD_DB1 PORTD.1 'D1 to pin 8 on LCD
'         #define GLCD_DB2 PORTD.2 'D2 to pin 9 on LCD
'         #define GLCD_DB3 PORTD.3 'D3 to pin 10 on LCD
'         #define GLCD_DB4 PORTD.4 'D4 to pin 11 on LCD
'         #define GLCD_DB5 PORTD.5 'D5 to pin 12 on LCD
'         #define GLCD_DB6 PORTD.6 'D6 to pin 13 on LCD
'         #define GLCD_DB7 PORTD.7 'D7 to pin 14 on LCD
'
'
'         #define GLCD_RS PORTa.0
'         #define GLCD_Enable PORTA.1
'         #define GLCD_RW PORTA.2
'         #define GLCD_RESET PORTA.3



#include <..\converters\Anobium.BMP>
' redefine the BMP to minimise changes to code.
#define TestDataSource Anobium
#include <glcd.h>


' These must be WORDs as this a large table.
dim TableReadPosition, TableLen as word

OptmiseGLCDDraw  = 0            ; either 0 or 1.  Needs to match the background pixel state.

' Start of code
TableReadPosition = 1
ReadTable TestDataSource, TableReadPosition, objwidth: TableReadPosition++
ReadTable TestDataSource, TableReadPosition, objHeight: TableReadPosition++

' draw at the upper left corner is set with GLCDXPos, GLCDYPos
        GLCDXPos = 0
        GLCDYPos = 0

        oldGLCDXPos = GLCDXPos
        TableReadPosition = 3

        WholeYBytes = objHeight /  8               ; Number of whole bytes within Y Axis.  This is integer maths!

        onPageBoundary = ( GLCDYPos % 8 ) = 0      ; If GLCDYPos as a memory page boundary.  Used to fast write the byte

          if WholeYBytes <> 0 then

              for hCount = 0 to (WholeYBytes - 1)  ; counter to number of whole bytes

                  ' it is safe to use GLCDY and X here as PSET is not called when this is used as a variable
                    GLCDY = GLCDYPos+hCount
                    for widthCount = 0 to (objwidth - 1)  ; increment thru bytes horizontally
                        ReadTable TestDataSource, TableReadPosition, wByte: TableReadPosition++   ; get the next byte
                        if wByte <> OptmiseGLCDDraw then             ; if the incoming byte is the same as the background, dont draw
                           ' So,  we have to draw this byte
                           ' If a a page boundary  this is a faster draw routine
                           if onPageBoundary = true then
                              ' use fast draw byte - essentially just write the data out, no, reading whats there.
                              GLCDX = GLCDXPos+widthCount
                              If GLCDX.6 = Off Then
                                 Set GLCD_CS2 On
                                 Set GLCD_CS1 off
                              end if
                              If GLCDX.6 = On Then
                                 Set GLCD_CS1 On
                                 GLCDX -= 64
                                 Set GLCD_CS2 off
                              end if

                              'Select page
                              CurrPage = GLCDY / 8
                              Set GLCD_RS Off
                              GLCDWriteByte b'10111000' Or CurrPage
                      		
                              'Select column
                              GLCDWriteByte 64 Or GLCDX
                              'Write data back
                              Set GLCD_RS On
                              GLCDWriteByte wByte

                           else

                              ' slow draw using X Y position and interate throught the bits
                              For CurrCharRow = 0 to 7
                                        If wByte.0 = 0 Then
                                                  PSet GLCDXPos+widthCount, CurrCharRow + GLCDYPos, GLCDBackground
                                        Else
                                                  PSet GLCDXPos+widthCount, CurrCharRow + GLCDYPos, GLCDForeground
                                        End If
                                        Rotate wByte Right
                              Next
                           end if

                         end if

                    next widthCount

                    GLCDXPos =  oldGLCDXPos
                    GLCDYPos = GLCDYPos + 8

              next hCount

          end if

          maxHeight = objHeight % 8       ; calculate the remaining bits

          'writes and remaining bits, if any
          if maxHeight <> 0 then

            for widthCount = 0 to objwidth - 1
              ReadTable TestDataSource, TableReadPosition, wByte: TableReadPosition++
                  ' slow draw using X Y position and interate throught the bits
                  For CurrCharRow = 0 to maxHeight-1
                            If wByte.0 = 0 Then
                                      PSet GLCDXPos+widthCount, ( CurrCharRow + GLCDYPos ), GLCDBackground
                            Else
                                      PSet GLCDXPos+widthCount, ( CurrCharRow + GLCDYPos ), GLCDForeground
                            End If
                            Rotate wByte Right
                  Next
            next
          end if
          Set GLCD_CS1 Off
          Set GLCD_CS2 Off
