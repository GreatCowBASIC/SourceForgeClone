    '  FILE:    TestRoutine_16LF1939_for_PCD8455@32.gcb
    '  DATE:    08/11/14
    '  VERSION: 1.3
    '  AUTHOR:  Anobium
    '

    'This program was written using the Great Cow Basic IDE for use with the PIC
    'Microchio development board and a Nokia 3310 LCD. It is a nice small graphical LCD, suitable for a lot of various projects.
    'The display is 38*35 mm, with an active display surface of 30*22 mm, and a 84*48 pixel resolution.
    'The display is easy to interface, using an SPI type of communication.
    'A 1-10 uF electrolytic capacitor from VOUT to GND, is the only external component needed..
    '
    'You may copy, alter and reuse this code in any way you like, but please leave
    'reference to Great Cow Basic and Anobium in your comments if you redistribute this code.
    '
    'THIS SOFTWARE IS PROVIDED "AS IS". WE MAKE, OR PROVIDE, ANY WARRANTIES,
    'WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
    'WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ACCURACY OR
    'LACK OF NEGLIGENCE. ANOBIUM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE
    'FOR ANY DAMAGES INCLUDING, BUT NOT LIMITED TO, SPECIAL, INCIDENTAL OR
    'CONSEQUENTIAL DAMAGES FOR ANY REASON WHATSOEVER.

    '1.02 change x pos of straing only. No functional changes.

    'Chip Settings. Assumes the my development board 'C' with with a 16LF1939
    #chip 16lf1939,32
    #config Osc = INT, MCLRE_ON, PLLEN_Off, CLKOUTEN_OFF

        #include <glcd.h>

        #DEFINE GLCD_TYPE GLCD_TYPE_PCD8544
        '#DEFINE GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY

        ' Comment out following paragraph for a non LAT port configuration and for ATMEL etc. devices.
         #define GLCD_LAT

         ' Pin mappings for Nokia 3310 Device please use LAT and Port definitions as appropiate
              #define GLCD_DO latc.5
              #define GLCD_SCK latc.3
              #define GLCD_DC latc.2
              #define GLCD_CS latc.1
              #define GLCD_RESET latc.0

              #define _GLCD_DO portc.5
              #define _GLCD_SCK portc.3
              #define _GLCD_DC portc.2
              #define _GLCD_CS portc.1
              #define _GLCD_RESET portc.0

          ' Pin mappings for SPI for Nokia 3310 Device
          ' None LAT configurations
    '          #define GLCD_DO portc.5
    '          #define GLCD_SCK portc.3
    '          #define GLCD_DC portc.2
    '          #define GLCD_CS portc.1
    '          #define GLCD_RESET portc.0

    ' write delay of 0 is works at 32mhz.
    #define PCD8544ClockDelay 0
    ' write delay of 0 is works at 32mhz.
    #define PCD8544WriteDelay 0

    GLCDCLS

          CCount = 0
          dim longNumber as long
          longNumber = 123456 ' max value = 4294967290
          dim wordNumber as Word
          dim outstring as string
          wordNumber = 0
          byteNumber = 0

              dim lengthofpicture, ram_index as word

              ' Display a BMP
              GLCDCLS


              ' Add your own case statement here to handle multiple BMPs, you just  need the variables to be defined
              ReadTable Anobium84_48, 0, lengthofpicture
              ReadTable Anobium84_48, 1, widthofpicture
              ReadTable Anobium84_48, 2, heightofpicture


              ' For BMP that fit the display simple write the data to the screen
              if widthofpicture = 0x54 then
                  for  ram_index =  3 to lengthofpicture          ; start at third byte and finish at the end

                            ' Add your own case statement here to handle multiple BMPs, you just  need set CurrCharVal to the data value
                            ReadTable Anobium84_48,  ( ram_index ), CurrCharVal

                            Write_Data_PCD8544(CurrCharVal)
                            #ifndef GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY
                                PCD8544_BufferAlias( ram_index - 2) = CurrCharVal  ' Start at index 1!
                            #endif
                  next


              else                                    ' For BMPs that do not fit the display, slow write.... lots of calcs....


                  CharLocX = 0                       ' specify X pos for BMP
                  CharLocY = 0                       ' specify Y pos for BMP.  For buffer any valid Y, for non-buffered 0,8,16, 24 etc...
                  OrgCharLocX = CharLocX              ' specify X orginisal X pos
                  firstpass = true                    ' specify this is the first pass

                  #ifdef GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY              ' handle non buffered devices
                            Cursor_Position_PCD8544 ( CharLocX , CharLocY ) ' position cursor
                  #endif

                  for  ram_index =  3 to lengthofpicture          ; start at third byte and finish at the end

                            ' Add your own case statement here to handle multiple BMPs, you just  need set CurrCharVal to the data value
                            ReadTable Anobium84_48,  ( ram_index ), CurrCharVal  ' read data

                            if ( ( ram_index - 3 ) % widthofpicture ) = 0  and firstpass = false then     ' change position for new line of data
                               CharLocY = CharLocY + 8
                               CharLocX = OrgCharLocX
                               #ifdef GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY
                                      Cursor_Position_PCD8544 ( CharLocX , CharLocY )
                               #endif

                            end if

                            #ifndef GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY           ' draw to buffer, and display using PSET
                                    For CurrCharRow = 0 to 7
                                        if ( CharLocY + CurrCharRow < GLCD_HEIGHT ) and ( CharLocX < GLCD_WIDTH ) then
                                            If CurrCharVal.0 = 0 Then
                                               PSet CharLocX , CharLocY + CurrCharRow, GLCDBackground
                                            Else
                                               PSet CharLocX , CharLocY + CurrCharRow, GLCDForeground
                                            End If
                                        end if
                                        Rotate CurrCharVal Right
                                    Next
                            #endif

                            #ifdef GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY               ' write to display - un-buffered
                                    Write_Data_PCD8544(CurrCharVal)
                            #endif
                            firstpass = false                                          ' now this is NOT the first pass
                            CharLocX++                                                 ' increment the X pos
                  next
              end if
              wait 1 s
              GLCDCLS


          DO forever
             for CCount = 31 to 127
                  GLCDPrint (0, 0, "PrintStr")
                  GLCDDrawString (0, 9, "DrawStr")
                  GLCDPrint ( 44 ,  21, "     ")
                  GLCDPrint ( 44 ,  29, "     ")                                           ' word value
                  GLCDPrint ( 44 ,  37, "   ")                                             ' Byte value

                  outstring = hex( longNumber_U)
                  GLCDPrint ( 44 , 21,outstring )
                  outstring = hex( longNumber_H)
                  GLCDPrint ( 55 , 21, outstring)
                  outstring = hex( longNumber)
                  GLCDPrint ( 67 , 21,  outstring )

                  GLCDPrint ( 44 , 29, mid( str(wordNumber),1, 6))
                  GLCDPrint ( 44 , 37, byteNumber)

                  box 46,9,57,19
                  GLCDDrawChar(48, 9, CCount )
                  outString = str( CCount )
                  ' draw a box to overwrite existing strings
                  FilledBox(58,9,GLCD_WIDTH-1,17,GLCDBackground )
                  GLCDDrawString(58, 9, outString )

                   box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1
                   box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1
                   filledbox 2,30,6,38, wordNumber
                   Circle( 25,30,8,1)            ;center
                   FilledCircle( 25,30,4,longNumber xor 1)         ;center

                   line 0,  GLCD_HEIGHT-1 , GLCD_WIDTH/2,  (GLCD_HEIGHT /2) +1
                   line  GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1 ,0, (GLCD_HEIGHT /2) +1


                  longNumber = longNumber + 7
                  wordNumber = wordNumber + 3
                  byteNumber++
              NEXT
          LOOP

      end





    Table Anobium84_48 as Byte

    ' start data
    0x54
    0x30
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x80
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x80
    0xF0
    0x9C
    0xE7
    0x38
    0x0E
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x02
    0x06
    0x0D
    0x0B
    0x1E
    0x34
    0x68
    0xD8
    0xF0
    0x60
    0xC0
    0x80
    0x80
    0x80
    0xC0
    0xC0
    0x40
    0x40
    0x60
    0x60
    0x60
    0x20
    0x20
    0x20
    0x30
    0x30
    0x10
    0x10
    0x10
    0x18
    0x18
    0x08
    0x0E
    0x1B
    0x7E
    0xE3
    0x80
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0xC0
    0x20
    0xC0
    0x00
    0x00
    0x01
    0x7F
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0xE0
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x20
    0x00
    0x03
    0x07
    0x0C
    0x08
    0x30
    0x60
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0xC0
    0x38
    0x16
    0x11
    0x10
    0x11
    0x16
    0x38
    0xC0
    0x00
    0xFF
    0x02
    0x01
    0x01
    0x01
    0xFE
    0x00
    0x00
    0x7E
    0x81
    0x81
    0x81
    0x81
    0x7E
    0x00
    0x00
    0xFF
    0x42
    0x81
    0x81
    0x81
    0x7E
    0x00
    0x00
    0xFF
    0x00
    0x00
    0x7F
    0x80
    0x80
    0x80
    0x40
    0xFF
    0x00
    0x00
    0xFF
    0x02
    0x01
    0x01
    0x01
    0xFE
    0x02
    0x01
    0x01
    0x01
    0xFE
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x3E
    0x60
    0x40
    0xC0
    0x80
    0x80
    0x80
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x80
    0xC0
    0xE0
    0x70
    0x18
    0x0C
    0x06
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x01
    0x01
    0x01
    0x03
    0x02
    0x06
    0x06
    0x04
    0x0C
    0x08
    0x18
    0x18
    0x10
    0x30
    0x20
    0x60
    0x60
    0x40
    0x60
    0x30
    0x18
    0x0C
    0x06
    0x03
    0x01
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    0x00
    End Table
